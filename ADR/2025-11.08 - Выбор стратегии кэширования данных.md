**Дата:** 7 ноября 2025 г.

**Статус:** Принято

### **Контекст**

В системе предполагаются интенсивные операции чтения данных — поиск мероприятий, загрузка списка концертов, отображение схем залов, отзывов и истории покупок.
Для обеспечения высокой производительности и снижения нагрузки на основную базу данных необходимо реализовать эффективную стратегию кэширования.

Система должна:

* Уменьшать время отклика API и ускорять загрузку пользовательских страниц.
* Снижать количество обращений к PostgreSQL.
* Обеспечивать актуальность данных при изменениях (например, при бронировании или возврате билетов).
* Поддерживать горизонтальное масштабирование и работу в распределённой архитектуре.

### **Рассмотренные варианты**

1. **Redis (In-memory кэш)**
   **Плюсы:**

   * Высокая скорость чтения и записи.
   * Поддержка TTL (time-to-live) и автоматического удаления устаревших данных.
   * Подходит для распределённых микросервисных архитектур.
   * Возможность хранения различных структур данных (строки, хэши, списки, множества).
   * Простая интеграция с Node.js / NestJS.

   **Минусы:**

   * Данные хранятся в памяти, что увеличивает стоимость инфраструктуры.
   * Необходима настройка политики сброса (eviction) при переполнении памяти.

2. **Memcached**
   **Плюсы:**

   * Простая и быстрая система кэширования для ключ-значение.
   * Хорошая производительность при простых запросах.

   **Минусы:**

   * Не поддерживает сложные структуры данных.
   * Отсутствует механизм долговременного хранения данных
   * Не подходит для микросервисной синхронизации.

3. **Локальное кэширование (in-memory, например, LRU Cache)**
   **Плюсы:**

   * Простота реализации.
   * Быстрая работа без сетевых вызовов.

   **Минусы:**

   * Не синхронизируется между инстансами.
   * Потеря данных при перезапуске сервера.
   * Не подходит для распределённой архитектуры.

4. **Гибридный подход (Redis + локальный кэш)**
   **Плюсы:**

   * Баланс между скоростью доступа и масштабируемостью.
   * Redis хранит глобальные данные, а локальный кэш используется для частых запросов внутри одного инстанса.
   * Возможность тонкой настройки TTL и инвалидации.

   **Минусы:**

   * Более сложная реализация.
   * Необходимость синхронизации между слоями кэширования.

### **Решение**

Выбран **Redis** как основная система кэширования, с использованием **гибридного подхода (Redis + локальный кэш)** для повышения производительности.

### **Обоснование**

* **Производительность:** Redis обеспечивает минимальную задержку при чтении данных, что особенно важно для операций поиска и фильтрации концертов.
* **Масштабируемость:** Поддержка кластеризации и репликации Redis позволяет обслуживать десятки тысяч запросов в секунду.
* **Гибкость:** Возможность задавать TTL для различных типов данных — от списка концертов (5–10 минут) до сеансов пользователей (1 час).
* **Интеграция:** Простое подключение через NestJS CacheModule и возможность использования Redis Streams для синхронизации событий.
* **Отказоустойчивость:** Поддержка master-replica и автоматического восстановления при сбоях.
* **Локальный слой:** Использование in-memory LRU-кэша для часто запрашиваемых данных внутри одного инстанса снижает сетевые обращения к Redis.

### **Последствия**

* В проекте будет внедрён **Redis Cluster** с политикой репликации и TTL для различных сущностей.
* Для API, отдающих данные о концертах, будет использоваться промежуточный слой кэширования (Redis + локальный LRU).
* Все изменения в данных (создание, бронирование, покупка, отмена) будут сопровождаться **инвалидацией кэша**.
* DevOps-команда настроит мониторинг Redis (через Prometheus/Grafana) и политику резервного копирования данных (RDB + AOF).
* Возможна интеграция Redis Pub/Sub для обновления данных в реальном времени (например, изменение доступности мест).
